{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"FilterComp <p>Welcome to FilterComp, a tool developed by Safe Solutions Engenharia for filtering, processing, and comparing datasets using the flash calculation logic from DWSIM.</p> <p>This tool was designed to streamline data analysis pipelines, enabling users to filter large datasets based on dynamic criteria, apply statistical and logical comparisons.</p>"},{"location":"#project-structure","title":"Project Structure","text":"<p>Below is the core structure of the project, highlighting the most important components you'll interact with. The <code>src/</code> directory contains all the logic and entry points for running and testing the tool, while <code>utils/</code> groups the main modules responsible for file operations, formatting, filtering, and logging.</p> <pre><code>filtercomp/\n\u2502\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 utils/\n\u2502   \u2502   \u251c\u2500\u2500 file_saver.py        # Handles data saving\n\u2502   \u2502   \u251c\u2500\u2500 format_files.py      # Handles data formatting\n\u2502   \u2502   \u251c\u2500\u2500 logger.py            # Logging setup and utilities\n\u2502   \u2502   \u251c\u2500\u2500 operation_filter.py  # Filtering logic after flashing operations\n\u2502   \u2502   \u2514\u2500\u2500 operations.py        # Defines flashing operations\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 tests/                   # Unit tests for core functionality\n\u2502   \u2514\u2500\u2500 main.py                  # Main file\n\u2502\n\u2514\u2500\u2500 requirements.txt             # Project dependencies\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! To contribute:</p> <ol> <li> <p>Fork the repository</p> </li> <li> <p>Create a new feature branch</p> </li> <li> <p>Make your changes and commit</p> </li> <li> <p>Open a pull request for review</p> </li> </ol>"},{"location":"configuration/","title":"Input Configurations","text":""},{"location":"configuration/#enums","title":"Enums","text":"<p>Enums provide named symbolic constants, making the code more understandable and less error-prone.</p>"},{"location":"configuration/#dwsim-packages","title":"DWSIM Packages","text":"<p>Used to select the thermodynamic model from DWSIM, which governs how physical and chemical properties are calculated.</p> DWSIM Packages <pre><code>class DWSIMPackage(Enum):\n    ActivityCoefficient = 'ActivityCoefficient'\n    BlackOil = 'BlackOil'\n    CAPEOPEN = 'CAPEOPEN'\n    ChaoSeader = 'ChaoSeader'\n    CoolProp = 'CoolProp'\n    CoolPropIncompressibleMixture = 'CoolPropIncompressibleMixture'\n    CoolPropIncompressiblePure = 'CoolPropIncompressiblePure'\n    DebyeHuckel = 'DebyeHuckel'\n    ElectrolyteBase = 'ElectrolyteBase'\n    ElectrolyteNRTL = 'ElectrolyteNRTL'\n    ExUNIQUAC = 'ExUNIQUAC'\n    GraysonStreed = 'GraysonStreed'\n    Raoult = 'Raoult'\n    LKP = 'LKP'\n    LIQUAC2 = 'LIQUAC2'\n    MODFAC = 'MODFAC'\n    NISTMFAC = 'NISTMFAC'\n    NRTL = 'NRTL'\n    PengRobinson = 'PengRobinson'\n    PengRobinson1978 = 'PengRobinson1978'\n    PengRobinsonLK = 'PengRobinsonLK'\n    PRSV2 = 'PRSV2'\n    PRSV2VL = 'PRSV2VL'\n    Seawater = 'Seawater'\n    SRK = 'SRK'\n    SourWater = 'SourWater'\n    SteamTables = 'SteamTables'\n    UNIFAC = 'UNIFAC'\n    UNIFACLL = 'UNIFACLL'\n    UNIQUAC = 'UNIQUAC'\n    Wilson = 'Wilson'\n</code></pre>"},{"location":"configuration/#format-type","title":"Format Type","text":"<p>Used to standardize the input <code>.xlsx</code> file format to match the default output structure used during the processing phase.</p> Format Type <pre><code>class FormatType(Enum):\n    DEFAULT = 'Default'\n</code></pre>"},{"location":"configuration/#filter-operations","title":"Filter Operations","text":""},{"location":"configuration/#operation-type","title":"Operation Type","text":"<p>Defines types of operations that can be performed in the filtering phase.</p> Operations Filter <pre><code>class OperationsFilter(Enum):\n    CALORIFIC_VALUE = 0\n    CO2_AND_H2S_FRACTION = 1\n    DISPERSION = 2\n    CO2_FRACTION = 3\n</code></pre>"},{"location":"configuration/#phase-type","title":"Phase Type","text":"<p>Represents the phase of the material stream: overall, vapor, oily, or aqueous.</p> Phase Type <pre><code>class PhaseType(Enum):\n    OVERALL = 'Overall'\n    VAPOR = 'Vapor'\n    OIL = 'Liquid1'\n    WATER = 'Liquid2'\n</code></pre>"},{"location":"configuration/#compound-basis","title":"Compound Basis","text":"<p>Defines the reference basis for compound data, with an associated default unit depending on the selected basis.</p> Compound Basis <pre><code>class CompoundBasis(Enum):\n    MOLE_FRAC = 'MolarComposition'\n    MASS_FRAC = 'MassComposition'\n    MOLE_FLOW = 'CompoundMolarFlow'\n    MASS_FLOW = 'CompoundMassFlow'\n\n    @property\n    def default_unit(self):\n        return {\n            CompoundBasis.MASS_FLOW: 'kg/h',\n            CompoundBasis.MOLE_FLOW: 'kmol/h',\n            CompoundBasis.MOLE_FRAC: None,\n            CompoundBasis.MASS_FRAC: None,\n        }.get(self, None)\n</code></pre>"},{"location":"configuration/#molar-flow-unit","title":"Molar Flow Unit","text":"<p>Specifies the unit of measurement for molar flow, used when a different unit is required instead of the default.</p> Molar Flow Unit <pre><code>class MolarFlowUnit(Enum):\n    KMOL_H = 'kmol/h'\n    KMOL_S = 'kmol/s'\n    MOL_S = 'mol/s'\n</code></pre>"},{"location":"configuration/#mass-flow-unit","title":"Mass Flow Unit","text":"<p>Specifies the unit of measurement for mass flow, used when a different unit is required instead of the default.</p> Mass Flow Unit <pre><code>class MassFlowUnit(Enum):\n    KG_H = 'kg/h'\n    G_H = 'g/h'\n    KG_S = 'kg/s'\n</code></pre>"},{"location":"configuration/#global-variables","title":"Global Variables","text":"<p>These global constants configure how the system reads input data, selects calculation options, handles logging, and writes results. They ensure consistent behavior across the application and should be set before processing begins.</p>"},{"location":"configuration/#file-and-path-configuration","title":"File and Path Configuration","text":"INPUT_FILE <p>Path to the input <code>.xlsx</code> file containing the composition data. <pre><code>INPUT_FILE = os.path.abspath(os.path.join(current_dir, '../../files/test_files/composicao_teste.xlsx'))\n</code></pre></p> OUTPUT_FOLDER <p>Directory to store the output files generated by the process. <pre><code>OUTPUT_FOLDER = os.path.abspath(os.path.join(current_dir, '../../files/test_files'))\n</code></pre></p> NAME <p>Descriptive name used to identify the final output file. <pre><code>NAME = 'composition_teste'\n</code></pre></p>"},{"location":"configuration/#processing-options","title":"Processing Options","text":"PACKAGE <p>Thermodynamic model selected from <code>DWSIMPackages</code>, used for property calculations inside DWSIM. <pre><code>PACKAGE = DWSIMPackages.PengRobinson1978\n</code></pre></p> FORMAT_TYPE <p>Used to standardize the input file format with the expected default structure during processing. <pre><code>FORMAT_TYPE = FormatType.DEFAULT\n</code></pre></p> FRACTION_PHASE <p>Specifies which phase (overall, vapor, oil, or water) will be used for fraction output. <pre><code>FRACTION_PHASE = PhaseType.OVERALL\n</code></pre></p> BASIS <p>Defines the basis for compound data. <pre><code>BASIS = CompoundBasis.MOLE_FLOW\n</code></pre></p> BASIS_UNIT <p>Set the unit associated with the selected <code>BASIS</code>, such as <code>'kmol/h'</code> for <code>MOLE_FLOW</code>. <pre><code>BASIS_UNIT = BASIS.default_unit\n</code></pre></p> OPERATION <p>Type of operation filter to apply (e.g., CO\u2082 filtering). <pre><code>OPERATION = OperationsFilter.CO2_FRACTION\n</code></pre></p> PHASE_TYPE <p>Defines the phase to consider during filtering. <pre><code>PHASE_TYPE = PhaseType.OVERALL\n</code></pre></p> ONLY_SIMULATED_VALUE <p>If <code>True</code>, only simulation-generated data is used. If <code>False</code>, pre-existing data in the input file will be included. <pre><code>ONLY_SIMULATED_VALUE = False\n</code></pre></p> DEBUG_MODE <p>When <code>True</code>, disables calculations like burn rate and evaporation, enabling debugging. <pre><code>DEBUG_MODE = False\n</code></pre></p>"},{"location":"configuration/#logging-configuration","title":"Logging Configuration","text":"LOG_TYPE <p>Sets the log verbosity level, e.g., <code>INFO</code>, <code>DEBUG</code>, <code>WARNING</code>, etc. <pre><code>LOG_TYPE = logging.INFO\n</code></pre></p> WRITE_LOGGER <p>Controls whether logs should be written to a file. <pre><code>WRITE_LOGGER = False\n</code></pre></p> LOG_PATH <p>File path where the logger output is written if <code>WRITE_LOGGER</code> is <code>True</code>. <pre><code>LOG_PATH = os.path.abspath(os.path.join(current_dir, '../../files/utils/composition_logs.log'))\n</code></pre></p>"},{"location":"database/","title":"Heat of Combustion Database","text":""},{"location":"database/#insert-new-or-update-members","title":"Insert New or Update Members","text":"<p>This module provides functionality to connect to a local SQLite database and insert a new record or update an existing one for the enthalpy of combustion of a chemical compound.</p> <p>To add or update a compound, define the following variables at the beginning of the script:</p> insert_to_database.py<pre><code>COMPOUND_NAME = 'Example compound'\nHEAT_OF_COMBUSTION = -1000 # kJ/kmol\n</code></pre> <p>This ensures the database always holds the most up-to-date information for each chemical compound.</p>"},{"location":"database/#delete-a-member","title":"Delete a Member","text":"<p>Not implemented yet!</p>"},{"location":"database/#check-all-members","title":"Check All Members","text":"<p>This module provides functionality to connect to a local SQLite database and retrieve the enthalpy of combustion data for all the chemical compounds inside the database.</p>"},{"location":"database/#check-a-specific-member","title":"Check a Specific Member","text":"<p>Not implemented yet!</p>"},{"location":"filtering/","title":"Operation Filters","text":""},{"location":"filtering/#overview","title":"Overview","text":"<p>This module defines classes and utilities for filtering data based on specific criteria. It processes each row of a dataframe, compares the relevant values, and selects the highest value according to the defined filter conditions.</p>"},{"location":"filtering/#calorific-value","title":"Calorific Value","text":"<p>The Calorific Value is calculated by combining:</p> <ul> <li>The composition of the fluid phase,</li> <li>The heat of combustion of each individual component,</li> <li>The molar flow rate of the phase.</li> </ul> <p>The Calorific Value is computed as:</p> \\[ \\text{Calorific Value} \\left(\\frac {kJ}{h} \\right) = \\left[ \\sum_{i} \\left( H_i \\cdot x_i \\right) \\right] \\cdot \\dot{n} \\] <p>Where:</p> <ul> <li>\\( H_i \\) =  Heat of combustion of component \\(i\\) \\((\\text{kJ/kmol})\\)</li> <li>\\( x_i \\) = Molar fraction (or relative molar contribution) of component \\(i\\)</li> <li>\\( \\dot{n} \\) = Total molar flow rate of the phase \\((\\text{kmol/h})\\)</li> </ul>"},{"location":"filtering/#co2-and-h2s-fraction","title":"CO\u2082 and H\u2082S Fraction","text":"<p>This class filters data based on the CO\u2082 and H\u2082S molar fractions. It processes each row of the input dataframes, identifies the maximum values for CO\u2082 and H\u2082S according to specific conditions, and selects the scenario that best meets the defined criteria.</p> <p>If the scenarios corresponding to the maximum CO\u2082 and H\u2082S values are different, the module compares their molecular weights: if the values are similar, the CO\u2082 and H\u2082S data are merged into a single stream; if they differ significantly, both streams are selected independently.</p>"},{"location":"filtering/#co2-fraction","title":"CO\u2082 Fraction","text":"<p>This class filters data based on the CO\u2082 molar fraction. It processes the input dataframes, identifies the scenario with the highest CO\u2082 content for each current, and selects the corresponding data.</p>"},{"location":"filtering/#create-a-new-filter","title":"Create a New Filter","text":"<p>To create a new filter, you need to follow three simple steps:</p>"},{"location":"filtering/#1-declare-the-new-filter-type","title":"1. Declare the new filter type","text":"<p>In <code>filter_operations.py</code>, extend the <code>OperationFilter</code> enum by adding a new entry.</p> filter_operations.py<pre><code>class OperationsFilter(Enum):\n    CALORIFIC_VALUE = 0\n    CO2_AND_H2S_FRACTION = 1\n    CO2_FRACTION = 3\n    NEW_FILTER = 4\n</code></pre>"},{"location":"filtering/#2-implement-the-new-filter-class","title":"2. Implement the new filter class","text":"<p>Create a new class in <code>operation_filter.py</code> that inherits from the base <code>Filter</code> class. Override and customize the logic as needed.</p> operation_filter.py<pre><code>class NewFilter(Filter):\n    def __init__(self, \n                 filter_type: OperationsFilter,\n                 flashed_df_dict: dict[str, pd.DataFrame], \n                 full_info_dict: dict[str, pd.DataFrame],\n                 composition_dict: dict[str, dict[str, list[float]]],\n                 phase_type: PhaseType,\n                 use_simulated_value: bool) -&gt; None:\n        super().__init__(filter_type,\n                         flashed_df_dict, \n                         full_info_dict,\n                         composition_dict,\n                         phase_type,\n                         use_simulated_value)\n</code></pre> <p>You can define methods within this class to handle unique parsing rules or transformations.</p>"},{"location":"filtering/#3-register-the-new-filter-in-the-factory","title":"3. Register the new filter in the factory","text":"<p>Update the <code>FilterFactory</code> to include the new filter class in its internal dictionary. This allows the factory to instantiate the correct class based on the filter type.</p> operation_filter.py<pre><code>class FilterFactory:\n    T = TypeVar('T', bound=Filter)\n\n    filter_classes: dict[OperationsFilter, type[Filter]] = {\n        OperationsFilter.CALORIFIC_VALUE: CalorificValue,\n        OperationsFilter.CO2_AND_H2S_FRACTION: CO2AndH2SFraction,\n        OperationsFilter.CO2_FRACTION: CO2Fraction,\n        OperationsFilter.NEW_FILTER: NewFilter\n    }\n</code></pre>"},{"location":"formatting/","title":"File Format Type","text":""},{"location":"formatting/#overview","title":"Overview","text":"<p>This module defines classes and utilities for formatting data from Excel spreadsheets.</p> <p>The key classes in this module are:</p> <ul> <li> <p><code>Format</code>: Abstract base class for formatting Excel sheets.</p> </li> <li> <p><code>FormatFactory</code>: Factory to return the appropriate format class based on type.</p> </li> </ul>"},{"location":"formatting/#create-a-new-format","title":"Create a New Format","text":"<p>To create a new data format, you need to follow three simple steps:</p>"},{"location":"formatting/#1-declare-the-new-format-type","title":"1. Declare the new format type","text":"<p>In <code>format_type.py</code>, extend the <code>FormatType</code> enum by adding a new entry.</p> format_type.py<pre><code>class FormatType(Enum):\n    DEFAULT = 'Default'\n    NEW_FORMAT = 'New_Format'\n</code></pre>"},{"location":"formatting/#2-implement-the-new-format-class","title":"2. Implement the new format class","text":"<p>Create a new class in <code>format_files.py</code> that inherits from the base <code>Format</code> class. Override and customize the logic as needed.</p> format_files.py<pre><code>class FormatNewFormat(Format):\n    def __init__(self, format_type: FormatType, data_dict: str) -&gt; None:\n        super().__init__(format_type, data_dict)\n        self._format_dicts()\n</code></pre> <p>You can define format-specific methods within this class to handle unique parsing rules or transformations.</p>"},{"location":"formatting/#3-register-the-new-format-in-the-factory","title":"3. Register the new format in the factory","text":"<p>Update the <code>FormatFactory</code> to include the new format class in its internal dictionary. This allows the factory to instantiate the correct class based on the format type.</p> format_files.py<pre><code>class FormatFactory:\n    T = TypeVar('T', bound=Format)\n\n    format_classes: dict[FormatType, type[Format]] = {\n        FormatType.NEW_FORMAT: FormatNewFormat,\n        FormatType.DEFAULT: FormatDefault\n    }\n</code></pre>"},{"location":"operations/","title":"Flash Operations","text":""},{"location":"operations/#overview","title":"Overview","text":"<p>A flash operation is a rapid phase separation process in which a liquid mixture is introduced into a flash drum, resulting in the formation of two distinct phases: a vapor phase and a liquid phase. This operation occurs rapidly and is based on the principle of phase equilibrium, where the vapor and liquid phases reach thermodynamic balance at a given temperature and pressure.</p> <p></p> <p>Simple flash drum example.</p>"},{"location":"operations/#flash-operation-logic","title":"Flash Operation Logic","text":"<p>In the code, two sequential flash operations are performed:</p>"},{"location":"operations/#1-first-flash-operation","title":"1. First Flash Operation","text":"<p>The first flash is executed using the temperature and pressure specified by the user.</p>"},{"location":"operations/#2-second-flash-operation","title":"2. Second Flash Operation","text":"<p>After the first separation, a second flash operation is performed. In this step, the system conditions are changed to ambient temperature and ambient pressure.</p>"},{"location":"operations/#flash-data-processing","title":"Flash Data Processing","text":"<p>The flash operation results, including phase compositions and thermodynamic properties, are extracted directly from DWSIM after each flash operation.</p> <p>However, two important properties \u2014 Burn Rate and Evaporation Rate \u2014 are not directly available from DWSIM. These properties are instead calculated within the code using:</p> <ul> <li> <p>A heat of combustion database; and</p> </li> <li> <p>Additional thermophysical property calculations.</p> </li> </ul> <p>This ensures that all necessary parameters are available for further analysis even when DWSIM does not provide them directly.</p>"},{"location":"operations/#burn-rate-calculation","title":"Burn Rate Calculation","text":"<p>The burn rate represents the rate at which a fuel combusts from a surface, expressed in units of \\((\\text{kg/m\u00b2s})\\). It quantifies how much mass of fuel burns per unit area per unit time.</p> <p>The burn rate is calculated using the following equation: $$ \\text{Burn Rate} \\left(\\frac {kg} {m\u00b2s}\\right) = 1.27 \\cdot 10^{\\text{-6}} \\rho_f \\left[    \\frac{\\Delta H_{\\text{c}}}        {\\Delta H_{\\text{v}} + c_p (T_{\\text{b}} - T_{\\text{f}})} \\right] $$</p> <p>Where:</p> <ul> <li>\\( \\rho_f \\) = Density of the fuel \\((\\text{kg/m}^3)\\)</li> <li>\\( \\Delta H_{\\text{c}} \\) = Heat of combustion \\((\\text{kJ/kg})\\)</li> <li>\\( \\Delta H_{\\text{v}} \\) = Heat of vaporization \\((\\text{kJ/kg})\\)</li> <li>\\( c_p \\) = Specific heat \\((\\text{kJ/kg\u00b7K})\\)</li> <li>\\( T_{\\text{b}} \\) = Boiling point temperature of the fuel \\((\\text{K})\\)</li> <li>\\( T_{\\text{f}} \\) = Actual fuel temperature \\((\\text{K})\\)</li> </ul>"},{"location":"operations/#evaporation-rate-calculation","title":"Evaporation Rate Calculation","text":"<p>The evaporation rate represents the mass of fuel evaporating per unit area per unit time, expressed in \\((\\text{kg/m\u00b2s})\\). It provides a measure of how quickly the liquid fuel transitions into the vapor phase under given conditions.</p> <p>The evaporation rate is calculated using the following equation: $$ \\text{Evaporation Rate} \\left(\\frac {kg} {m\u00b2s}\\right) = k \\cdot \\left( \\frac{T_{\\text{b}} - T_{\\text{f}}}{\\Delta H_{\\text{v}}} \\right) $$</p> <p>Where:</p> <ul> <li>\\( k \\) = Constant (for average soil and concrete; k = 10.5)</li> <li>\\( T_{\\text{b}} \\) = Boiling point temperature of the fuel \\((\\text{K})\\)</li> <li>\\( T_{\\text{f}} \\) = Actual fuel temperature \\((\\text{K})\\)</li> <li>\\( \\Delta H_{\\text{v}} \\) = Heat of vaporization \\((\\text{kJ/kg})\\)</li> </ul>"},{"location":"operations/#delta-t-calculation","title":"\\( \\Delta T \\) Calculation","text":"<p>The temperature difference, \\( \\Delta T \\), plays a critical role in both the Burn Rate and Evaporation Rate calculations, as it represents the temperature for both processes.</p> <p>In both cases, \\( \\Delta T \\) is the difference between the boiling point temperature of the fuel (\\( T_{\\text{b}} \\)) and the actual fuel temperature (\\( T_{\\text{f}} \\)).</p>"},{"location":"operations/#1-initial-temperature-loop","title":"1. Initial Temperature Loop","text":"<p>The Initial Temperature Loop iteratively adjusts the temperature difference (\\( \\Delta T \\)) to ensure the system reaches a stable state. Starting with an initial fuel temperature, a flash calculation is attempted at \\( T_{\\text{release}} \\) + \\( \\Delta T \\). If the flash succeeds and the vapor fraction is less than 1, (\\( \\Delta T \\)) is increased by 50 K, and the process repeats. If the flash fails, tolerances are adjusted, and the calculation is retried. This loop continues until the vapor fraction is 1.</p> <p>Here\u2019s a flowchart illustrating the Initial Temperature Loop:</p> <pre><code>  flowchart TD\n    A[Start] --&gt; B[Save state &amp; \n    set vapor_fraction = 0];\n    B --&gt; C[Loop: vapor_fraction &lt; 1];\n    C --&gt; D[Try flash calculation at \n    T = release + \u0394T];\n    D --&gt; E{Flash succeeds?};\n    E --&gt;|Yes| F{vapor_fraction &lt; 1?};\n    F --&gt;|Yes| G[Increase \u0394T by 50 K] --&gt; C;\n    F --&gt;|No| H[Go to refinement loop];\n    E --&gt;|No| I[Adjust tolerances \n    and retries] --&gt; D;</code></pre> <p>Flowchart illustrating the initial steps of the iterative temperature adjustment process in a flash operation.</p>"},{"location":"operations/#2-refinement-temperature-loop","title":"2. Refinement Temperature Loop","text":"<p>The Refinement Temperature Loop is a more detailed iteration process that follows the initial temperature loop. It begins by checking if the vapor fraction is greater than or equal to 1. If true, \\( \\Delta T \\) is decreased by 1 K, and a flash calculation is attempted. If the flash succeeds but the vapor fraction remains 1 or above, the loop continues. If the flash fails, tolerances are adjusted, and the calculation is retried. This process repeats until the vapor fraction is less than 1, and a refined temperature is found. Finally, the system returns the \\( \\Delta T \\).</p> <p>Here\u2019s a flowchart illustrating the Refinement Temperature Loop:</p> <pre><code>  flowchart TD\n    A[Refinement loop] --&gt; B[Loop: vapor_fraction &gt;= 1];\n    B --&gt; C[Decrease \u0394T by 1 K];\n    C --&gt; D[Try flash calculation];\n    D --&gt; E{Flash succeeds?};\n    E --&gt;|Yes| F{vapor_fraction &lt; 1?};\n    E --&gt;|No| G[Adjust tolerances \n    and retries] --&gt; D;\n    F --&gt; |No| B[Loop: vapor_fraction &gt;= 1];\n    F --&gt; |Yes| H[Refined temperature found];\n    H --&gt; I[Return \u0394T];</code></pre> <p>Flowchart illustrating the refinement steps of the iterative temperature adjustment process in a flash operation.</p>"},{"location":"setup/","title":"Setup Guide","text":""},{"location":"setup/#prerequisites","title":"Prerequisites","text":"<p>Ensure your system has the following installed:</p> <ul> <li>Python 3.10.1 (Different versions may cause compatibility issues with certain packages.)</li> <li>pip</li> <li>Git</li> <li>DWSIM</li> </ul>"},{"location":"setup/#cloning-the-project","title":"Cloning the Project","text":"<p>Clone the repository to your local machine: <pre><code>git clone https://github.com/Safe-Solutions-Engenharia/filtercomp.git\ncd filtercomp\n</code></pre></p>"},{"location":"setup/#creating-a-virtual-enviroment","title":"Creating a Virtual Enviroment","text":"<p>Create and activate a virtual environment:</p> WindowsLinux/macOS <pre><code>python -m venv venv\nvenv\\Scripts\\activate\n</code></pre> <pre><code>python3 -m venv venv\nsource venv/bin/activate\n</code></pre>"},{"location":"setup/#installing-dependencies","title":"Installing Dependencies","text":"<p>Install dependencies listed in requirements.txt:</p> <pre><code>pip install -r requirements.txt\n</code></pre>"}]}